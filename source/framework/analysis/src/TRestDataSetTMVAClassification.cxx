/*************************************************************************
 * This file is part of the REST software framework.                     *
 *                                                                       *
 * Copyright (C) 2016 GIFNA/TREX (University of Zaragoza)                *
 * For more information see https://gifna.unizar.es/trex                 *
 *                                                                       *
 * REST is free software: you can redistribute it and/or modify          *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation, either version 3 of the License, or     *
 * (at your option) any later version.                                   *
 *                                                                       *
 * REST is distributed in the hope that it will be useful,               *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          *
 * GNU General Public License for more details.                          *
 *                                                                       *
 * You should have a copy of the GNU General Public License along with   *
 * REST in $REST_PATH/LICENSE.                                           *
 * If not, see https://www.gnu.org/licenses/.                            *
 * For the list of contributors see $REST_PATH/CREDITS.                  *
 *************************************************************************/

/////////////////////////////////////////////////////////////////////////
/// TRestDataSetTMVAClassification performs the classification of a given
/// dataSet using as input the results of the TMVA evaluation methods
/// generated using TRestDataSetTMVA. Note that the observables used on
/// TRestDataSetTMVA and TRestDataSetTMVA needs to match. This class generates
/// as output a dataset with a new observable which is defined using the name of
/// the TMVA method that has been used to classify the dataset. Only one TMVA
/// method is classified in ClassifyTMVA. An output dataset is generated by
/// definining a new observable with the TMVA method e.g. BDT_score
///
/// A summary of the basic parameters is described below:
/// * **dataSetName**: Name of the dataSet to be classified
/// * **tmvaFile**: Name of the xml input file with the tmva weigths
/// * **tmvaMethod**: Name of the TMVA method used to classify
/// * **outputFileName**: Name of the output dataset
///
///
/// The different observables for the TMVA classification can be added with the following key:
/// \code
/// <observable name="tckAna_MaxTrack_XYZ_SigmaZ2" />
/// \endcode
/// * **name**: Name of the observable be computed
///
/// Note that the observable names has to match the ones using for the evaluation of
/// a particular TMVA method
///
/// Different cuts over the dataset can be added with the following key:
/// \code
///   <addCut name="ParamCut"/>
/// \endcode
///
/// ### Examples
/// Example of RML config file:
/// \code
/// <TRestDataSetTMVAClassification name="TMVA" verboseLevel="info">
///    <observable name="tckAna_MaxTrack_XYZ_SigmaZ2"/>
///    <observable name="tckAna_MaxTrackEnergyBalanceXY"/>
///    <observable name="tckAna_MaxTrackEnergyRatio"/>
///    <observable name="tckAna_MaxTrack_XZ_SigmaX" />
///    <observable name="tckAna_MaxTrack_YZ_SigmaY" />
///    <observable name="tckAna_MaxTrackxySigmaBalance"/>
///    <parameter name="tmvaFile" value="/myfolder/weights/TMVA_Classification_BDT.weights.xml" />
///    <parameter name="tmvaMethod" value="BDT" />
///    <addCut name="ParamCut"/>
///     <TRestCut name="ParamCut" verboseLevel="info">
///       <cut name="c1" variable="tckAna_nTracks_X" condition=">0" />
///       <cut name="c2" variable="tckAna_nTracks_Y" condition=">0" />
///       <cut name="c3" variable="tckAna_MaxTrackEnergyRatio" condition="<0.1" />
///       <cut name="c4" variable="tckAna_MaxTrack_XYZ_SigmaZ2" condition="<20." />
///       <cut name="c5" variable="tckAna_MaxTrackEnergyBalanceXY" condition="<5"/>
///       <cut name="c6" variable="tckAna_MaxTrackEnergyBalanceXY" condition=">-5"/>
///       <cut name="c7" variable="tckAna_MaxTrackxySigmaBalance" condition=">-1"/>
///       <cut name="c8" variable="tckAna_MaxTrackxySigmaBalance" condition="<1"/>
///     </TRestCut>
/// </TRestDataSetTMVAClassification>
/// \endcode
///
/// Example of TRestDataSetTMVAClassification using restRoot:
/// \code
///  TRestDataSetTMVAClassification tmva("tmva.rml");
///  tmva.SetDataSet("MyDataSet.root");
///  tmva.SetOutputFileName("MyClassifiedDataSet.root");
///  tmva.ClassifyTMVA();
/// \endcode
///
///----------------------------------------------------------------------
///
/// REST-for-Physics - Software for Rare Event Searches Toolkit
///
/// History of developments:
///
/// 2023-03: First implementation of TRestDataSetTMVAClassification
/// JuanAn Garcia
///
/// \class TRestDataSetTMVAClassification
/// \author: JuanAn Garcia   e-mail: juanangp@unizar.es
///
/// <hr>
///

#include "TRestDataSetTMVAClassification.h"

#include "ROOT/RDFHelpers.hxx"
#include "TMVA/CrossValidation.h"
#include "TMVA/DataLoader.h"
#include "TMVA/Factory.h"
#include "TMVA/RInferenceUtils.hxx"
#include "TMVA/RReader.hxx"
#include "TMVA/RTensorUtils.hxx"
#include "TMVA/Tools.h"
#include "TRestDataSet.h"

ClassImp(TRestDataSetTMVAClassification);

///////////////////////////////////////////////
/// \brief Default constructor
///
TRestDataSetTMVAClassification::TRestDataSetTMVAClassification() { Initialize(); }

/////////////////////////////////////////////
/// \brief Constructor loading data from a config file
///
/// If no configuration path is defined using TRestMetadata::SetConfigFilePath
/// the path to the config file must be specified using full path, absolute or
/// relative.
///
/// The default behaviour is that the config file must be specified with
/// full path, absolute or relative.
///
/// \param configFilename A const char* that defines the RML filename.
/// \param name The name of the metadata section. It will be used to find the
/// corresponding TRestDataSetTMVAClassification section inside the RML.
///
TRestDataSetTMVAClassification::TRestDataSetTMVAClassification(const char* configFilename, std::string name)
    : TRestMetadata(configFilename) {
    LoadConfigFromFile(fConfigFileName, name);
    Initialize();

    if (GetVerboseLevel() >= TRestStringOutput::REST_Verbose_Level::REST_Info) PrintMetadata();
}

///////////////////////////////////////////////
/// \brief Default destructor
///
TRestDataSetTMVAClassification::~TRestDataSetTMVAClassification() {}

///////////////////////////////////////////////
/// \brief Function to initialize input/output event members and define
/// the section name
///
void TRestDataSetTMVAClassification::Initialize() { SetSectionName(this->ClassName()); }

///////////////////////////////////////////////
/// \brief Function to initialize some variables from
/// configfile
///
void TRestDataSetTMVAClassification::InitFromConfigFile() {
    Initialize();
    TRestMetadata::InitFromConfigFile();

    TiXmlElement* obsDefinition = GetElement("observable");
    while (obsDefinition != nullptr) {
        std::string obsName = GetFieldValue("name", obsDefinition);
        if (obsName.empty() || obsName == "Not defined") {
            RESTError << "< observable variable key does not contain a name!" << RESTendl;
            exit(1);
        } else {
            fObsName.push_back(obsName);
        }

        obsDefinition = GetNextElement(obsDefinition);
    }

    TiXmlElement* cutele = GetElement("addCut");
    while (cutele != nullptr) {
        std::string cutName = GetParameter("name", cutele, "");
        if (!cutName.empty()) {
            if (fCut == nullptr) {
                fCut = (TRestCut*)InstantiateChildMetadata("TRestCut", cutName);
            } else {
                fCut->AddCut((TRestCut*)InstantiateChildMetadata("TRestCut", cutName));
            }
        }
        cutele = GetNextElement(cutele);
    }

    if (fOutputFileName == "") fOutputFileName = GetParameter("outputFileName", "");
}

/////////////////////////////////////////////
/// \brief This function computes the TMVA classification
/// for a given dataSet. It requires a xml file with weigths
/// from the output of TRestDataSetTMVA to perform the
/// clasification for a given set of observables. This function
/// defines a new observable with the score of the TMVA method
/// provided in the input file that can be used for further
/// signal and background discrimination.
///
void TRestDataSetTMVAClassification::ClassifyTMVA() {
    PrintMetadata();

    if (fObsName.empty()) {
        RESTError << "No observables provided, exiting..." << RESTendl;
        exit(1);
    }

    TMVA::Reader reader("!Color:!Silent");
    std::vector<Float_t> var(fObsName.size());

    // Add variables to the reader
    for (unsigned int i = 0; i < fObsName.size(); i++) {
        reader.AddVariable(fObsName[i].c_str(), &var[i]);
    }

    // Book TMVA method
    reader.BookMVA(fTmvaMethod.c_str(), fTmvaFile.c_str());

    // Lambda for evaluation of the method
    auto eval = [&reader = reader, &tmvaMethod = fTmvaMethod](const std::vector<double>& val) {
        return reader.EvaluateMVA(val, tmvaMethod.c_str());
    };

    TRestDataSet dataSet;
    dataSet.Import(fDataSetName);

    auto df = dataSet.MakeCut(fCut);

    std::string obsName = fTmvaMethod + "_score";

    // Ugly but cannot pass vector size to ROOT::RDF::PassAsVec
    switch (fObsName.size()) {
        case 1:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<1, double>(eval), fObsName);
            break;
        case 2:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<2, double>(eval), fObsName);
            break;
        case 3:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<3, double>(eval), fObsName);
            break;
        case 4:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<4, double>(eval), fObsName);
            break;
        case 5:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<5, double>(eval), fObsName);
            break;
        case 6:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<6, double>(eval), fObsName);
            break;
        case 7:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<7, double>(eval), fObsName);
            break;
        case 8:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<8, double>(eval), fObsName);
            break;
        case 9:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<9, double>(eval), fObsName);
            break;
        case 10:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<10, double>(eval), fObsName);
            break;
        case 11:
            df = df.Define(obsName.c_str(), ROOT::RDF::PassAsVec<11, double>(eval), fObsName);
            break;
        default:
            RESTError << "Number of observables " << fObsName.size() << " is not supported" << RESTendl;
            exit(1);
    }

    dataSet.SetDataFrame(df);

    if (!fOutputFileName.empty()) {
        if (TRestTools::GetFileNameExtension(fOutputFileName) == "root") {
            dataSet.Export(fOutputFileName);
            TFile* f = TFile::Open(fOutputFileName.c_str(), "UPDATE");
            this->Write();
            f->Close();
        }
    }
}

/////////////////////////////////////////////
/// \brief Prints on screen the information about the metadata members of TRestDataSetTMVAClassification
///
void TRestDataSetTMVAClassification::PrintMetadata() {
    TRestMetadata::PrintMetadata();

    RESTMetadata << " Observables to compute: " << RESTendl;
    for (size_t i = 0; i < fObsName.size(); i++) {
        RESTMetadata << fObsName[i] << RESTendl;
    }
    RESTMetadata << "----" << RESTendl;
}
